# 옵티마이저와 힌트

### 옵티마이저 (Optimizer)

- DBMS의 두뇌
- SQL을 가장 빠르고 효율적으로 수행할 수 있도록 도와준다
- 최적의 실행 계획을 수립한다

### 9.1.1 쿼리 실행 절차

1. 사용자로부터 요청된 SQL 문장을 잘개 쪼개 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다. 
2. SQL의 파싱정보를 확인하면서 어떤 테이블로 부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로 부터 데이터를 가져온다

### 9.1.2 옵티마이저의 종류

1. 비용 기반 최적화
    - 테이블의 예측된 통계 정보를 사용해 실행 계획별 비용을 산출한다. 이렇게 산출된 실행 방법별로 비용이 최소로 소요되는 방법을 선택한다.
2. 규칙 기반 최적화 
    - 테이블의 레코드 건수나 선택도를 고려하지 않고 내장된 우선순위에 따라 실행계획을 수립한다.
    - 각 테이블이나 인덱스의 통계 정보가 거의 없고 상대적으로 느린 CPU 연산 으로 사용되지 않는다.

> 대부분의 RDBMS는 비용 기반 최적화를 이용한다
> 

### 9.3 고급 최적화

- 옵티마이저 옵션
    - 조인 관련
    - 옵티마이저 스위치
- 옵티마이저 스위치
    - 옵티마이저 스위치 옵션은 `optimizer_switch` 시스템 변수를 통해 제어한다
    - `default` `on` `off` 중에서 하나를 설정한다
    - 글로벌과 세션별 모두 설정할 수 있는 시스템 변수 이다.

**MRR과 배치 키 엑세스**

- MRR은 Multi-Range-Read로 Disk Sweep Multi-Range Read 라고 불리기도 한다
- MySQL에서 지금까지 지원한 조인 방식은 드라이빙 테이블 (조인에서 가장 먼저 읽는 테이블) 의 레코드를 한 건읽어서 드리븐 테이블 (드라이빙 테이블이 아닌 테이블)의 일치하는 레코드를 찾아 조인하는 `네스티드 루프 조인` 방식 이였다.
- 조인 처리는 MySQL 엔진이 담당하지만 실제 레코드를 검색하고 읽는 부분은 스토리지 엔진이 담당한다. 드라이빙 테이블의 레코드 건별로 드리븐 레코드의 레코드를 찾으면 레코드를 찾고 있는 스토리지 엔진에서는 최적화를 수행 할 수 없다.

위와 같은 단점을 보완하기 위해 MySQL 서버는 조인 대상 테이블 중 하나로부터 레코드를 읽어 버퍼링한다

- 드라이빙 테이블의 레코드를 읽어 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인 대상을 버퍼링 한다
- 조인 버퍼에 레코드가 가득 차면 MySQL 엔진은 버퍼링 된 레코드를 스토리지 엔진으로 한 번에 요청한다

> 스토리지 엔진의 최적화를 위해 사용된다
> 

**블록 네스티드 루프 조인**

- MySQL 서버에서 사용되는 대부분의 조인은 네스티드 루프 조인 이고 조인의 연결 조건이 되는 컬럼에 모두 인덱스가 있을 경우 사용된다
- 드리븐 테이블의 조인 조건이 인덱스를 이용할 수 없으면 드리븐 테이블에서 연결되는 레코드를 찾기 위해 풀 테이블 스캔을 해야 한다
- 어떤 방식으로도 드리븐의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한후 드리븐 테이블과 메모리 캐시를 조인하는 `조인 버퍼` 형태로  처리한다
- 조인 버퍼가 사용되는 쿼리는 조인의 순서가 거꾸로인 것처럼 실행 된다.
- 실제 드라이빙 테이블의 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 진행된다.

> 8.0.18 버전 부터 해시 조인 알고리즘이 도입되어 블록 네스티드 루프 조인 대신 해시 조인 알고리즘이 사용된다
> 

**인덱스 컨디션 푸시 다운**

- 인덱스 조건을 스토리지 엔진으로 넘겨준다

`Using where` 

- where 조건으로 데이터를 추출한다
- type의 ALL, IDX 타입과 함께 표현되면 성능이 좋지 못함을 의미한다.
- Index를 사용할 수 없는 where 조건에 일치하는지 검사하는 과정

```java
select *
from temp_ad_offset
where customer_id = 7 and offset_type like '%LIST';
```

- 위 조건은 like 절에서 인덱스가 적용되지 않기 때문에 customer_id =7 은 인덱스를 통해 걸러내고  offset_type like %List는 인덱스가 적용되지 않기 때문에 걸러진 데이터를 테이블에서 하나씩 비교한다
- MySQL 5.6 부터 인덱스 범위 조건에 사용 될 수 없어도 인덱스에 포함된 필드라면 스토리지 엔진으로 전달해 최대한 스토리지 엔진에서 걸러낸 데이터만 MySQL 엔진에 전달한다
- 따라서 `Using where` 에서 `Using index condition` 으로 변경되었다

ref : [https://jojoldu.tistory.com/474](https://jojoldu.tistory.com/474)

**인덱스 확장**

- `using_index_extensions` 는 InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 PK를 활용할 수 있게 할지 결정하는 옵션이다
- PK : (dept_no,emp_no) 복합키
- Secondary Index : from_date

> 세컨더리 인덱스는 데이터 레코드를 찾아가기 위해 pk인 dept_no와 emp_no 칼럼을 순서대로 포함한다. 그래서 (from_date,dept_no,emp_no) 조합으로 인덱스를 생성한 것과 흡사하게 작동할 수 있게 된다
> 

**인덱스 머지**

- 인덱스를 이용해 쿼리를 실행하면 대부분의 경우 옵티마이저는 테이블 별로 하나의 인덱스만 사용하도록 한다
- 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리한다

**인덱스 머지 - 교집합**

- first_name , emp_no column이 각각 인덱스로 설정되어 있다면 2개중 어떤 조건을 사용하더라도 인덱스를 사용할 수 있다
- `Using intersect` 는 쿼리가 여러개의 인덱스를 각각 검색해서 그 결과의 교집합을 반환 한다

**인덱스 머지 - 합집합**

- `Using union` 은 where 절에 사용된 2개 이상의 조건이 각각의 인덱스를 사용하되 `OR` 연산자로 연결된 경우에 사용하는 최적화다

```java
SELECT *
FROM employees
where first_name = 'Matt' or hire_date = '1987-03-31';
```

- 위 Table에서 first_name 컬럼과 hire_date 컬럼에 각각 인덱스가 설정되어 있다
- 위 쿼리의 실행 계획은 각각의 인덱스를 사용하는 `Using union` 최적화를 사용한다

> SQL에서 AND 연산자와 OR 연산자는 큰 차이를 보인다. 2개의 조건이 AND로 연결된 경우는 두 조건 중 하나라도 인덱스를 사용할 수 있으면 인덱스 레인지 스캔으로 쿼리가 실행된다. 하지만 2개의 WHERE 조건이 OR로 연결된 경우는 둘 중 하나라도 제대로 인덱스를 사용하지 못하면 Full table scan 하게 된다
> 

**인덱스 머지 - 정렬 후 합집합**

- `Union` 알고리즘은 두 결과 집합의 중복을 제거 하기 위해 정렬된 결과를 필요로 하지만 MySQL 서버는 별도의 정렬을 수행하지 않는다
- 인덱스 머지 작업을 하는 도중 결과의 정렬이 필요한 경우 `Sort Union` 알고리즘을 사용한다
- 중복 제거를 위해 강제로 정렬을 수행해야 하는 경우 `Using sort_union` 문구가 표시된다

**세미 조인**

- 다른 테이블과 실제 조인을 수행하지는 않고 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 쿼리를 `세미 조인` 이라고 한다
- 서브 쿼리를 사용했을때 메인쿼리와의 연결 처리를 의미 한다
- `EXISTS` `NOT EXISTS` `IN` 를 사용하면 옵티마이저는 세미 조인 사용 여부를 판단한다
- 조인시 특정 조건에 부합된다면 더는 연산을 수행하지 않는다

**테이블 풀 아웃**

- `Table pullout` 최적화는 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후 쿼리를 조인 쿼리로 재작성 하는 형태의 최적화다
- `Using table pullout` 과 같은 문구가 출력되지 않는다
- 최대한 서브쿼리를 조인으로 풀어서 사용하는 것이 좋지만 최신 MySQL은 서브쿼리가 많이 최적화 되었다

ref : [https://jojoldu.tistory.com/520](https://jojoldu.tistory.com/520)

**퍼스트 매치**

- `First Match` 전략은 `IN` 형태의 세미 조인을 `EXISTS` 형태로 튜닝하는 것과 유사하다
- In 연산자의 처리 순서는 서브쿼리 → 메인 쿼리 이다. 따라서 서브에서 메인의 정보를 가져 올 수 없어 조건을 각각 설정한다
- exists 연산자는 메인쿼리 → 서브 쿼리 실행순서이다. 서브에서 메인의 정보를 가져와 처리 가능하다
- EXISTS는 ROW가 존재하는 지만 체크하고 더는 수행 되지 않지만 IN은 실제 존재하는 모든 데이터의 값을 확인한다. 따라서 EXIST 연산자가 효율적이다 → 일치하는 레코드 1건만 찾으면 더이상 수행하지 않는다
- FirstMatch 최적화는 상관 서브쿼리에서 사용될 수 있다
- 단 GROUP BY나 집합 함수가 사용된 서브쿼리 최적화에는 사용될 수 없다

**구체화**

- 구체화 최적화는 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적하는 것이다
- 내부 임시 테이블을 생성한다는 것을 의미한다
- GROUP BY나 집합 함수가 사용되도 구체화를 사용할 수 있다. 그러나 서브쿼리는 상관 서브쿼리가 아니여야 한다

**중복 제거**

- Duplicate WeedOut은 세미 조인 서브쿼리를 일반적은 INNER JOIN 쿼리로 바꿔 실행하고 마지막에 중복된 레코드를 제거하는 알고리즘이다

```java
SELECT * FROM employees e
WHERE e.emp_no IN (SELECT s.emp_no FROM salaries s
WHERE s.salary> 150000);
```

```java
SELECT e.*
FROM employees e, salaries s
where e.emp_no = s.emp_no and s.salary > 150000
group by e.emp_no;
```

- 위의 두 쿼리는 동일 하다
- 원본쿼리를 INNER JOIN + GROUP BY로 바꿔서 실행한다

**컨디션 펜아웃**

- 조인을 실행할때 테이블의 순서는 쿼리의 성능에 매우 큰 영향을 미친다
- 여러 테이블이 조인되는 경우 가능하다면 일치하는 레코드 건수가 적은 순서대로 조인을 실행한다
- 테이블 데이터 수 순서가 아니라 출력하고자 하는 값 중에 가장 작은 값부터 드라이빙 되게 순서를 정한다 ( 반드시 그런 것은 아니지만 일반적으로 적은 데이터로 하면 일치되는 레코드 건수가 적을 확률이 높다)

**파생 테이블 머지**

- 예전 버전의 MySQL 서버에서는 FROM 절에 사용된 서브쿼리는 먼저 실행해 임시 테이블로 만들었다
- 임시 테이블에 저장되는 레코드가 많아진다면 임시테이블로 레코드를 복사하고 읽는 오버헤드로 인해 쿼리 성능은 느려지게 된다
- `derived_merge` 최적화 옵션으로 임시 테이블 최적화를 진행해 많이 성능이 개선되었다
- 단, 아래의 경우에는 서브쿼리를 외부 쿼리로 수동으로 병합하는 것이 좋다

```java
1. 집계함수, 윈도우 함수가 쓰인 쿼리
2. DISTINCT 사용된 서브쿼리
3. GROUP BY , HAVING 사용된 서브쿼리
4. LIMIT 사용된 서브쿼리
5. UNION 또는 UNION ALL을 포함하는 서브쿼리
6. SELECT 절에 사용된 서브 쿼리
7. 값이 변경되는 사용자 변수가 사용된 서브쿼리
```

**인비저블 인덱스**

- MySQL 8.0 부터 인덱스를 삭제하지 않고 해당 인덱스르 사용하지 못하게 하는 제어 기능을 제공한다
- `ALTER TABLE ... ALTER INDEX [ VISIBLE | INVISIBLE]` 명령어를 통해 인덱스의 가용 형태를 변경한다

**스킵 스캔**

- 인덱스의 핵심은 값이 정렬되어 있으며 이로 인해 인덱스를 구성하는 컬럼의 순서가 매우 중요하다
- (A,B,C) 컬럼으로 구성된 인덱스가 있을때 쿼리의 WHERE 절에 A,B 컬럼 조건이 있으면 A컬럼 B컬럼 까지 인덱스를 활용할 수 있고 A 컬럼만 있으면 A 컬럼까지 인덱스를 활용할 수 있다
- WHERE 절에 B,C 컬럼에 대한 조건이 있으면 인덱스를 활용할 수 없는데 인덱스 스킵 스캔은 제한적으로 이런 제약 사양을 뛰어넘게 해준다
    - 옵티마이저는 테이블에 존재하는 모든 A 컬럼 값을 가져와 마치 A컬럼이 있는것처럼 최적화 한다
    - 선행 컬럼이 매우 다양한 값을 가지는 경우 오히려 비효율적이기 때문에 소수 유니크한 값을 가질때만 인덱스 스킵 스캔 최적화를 사용한다

```java
// 인덱스 스킵 스캔 활성화
SET optimizer_switch ='skip_scan=on';
```

**해시 조인**

- 해시 조인은 네스티드 조인에 비해 첫 번째 레코드를 찾는데는 시간이 많이 걸리지만 최종 레코드를 찾는데는 많이 걸리지 않는다
- 네스티드 조인은 첫번째 레코드는 빨리 찾지만 최종 레코드를 찾는데는 해시 조인보다 느리다
    - 해시 조인 쿼리는 Best Throughput에 적합
    - 네스티드 루프 조인은 Best Response-time에 적합
- 일반적인 웹 서비스는 온라인 트랜잭션 서비스여서 스루풋보다 응답속도가 더 중요하다
    - MySQL 서버는 주로 조인 조건의 컬럼이 인덱스가 없거나 조인 대상 테이블 중 일부의 레코드 건수가 매우 적은 경우만 해시 조인 알고리즘을 사용하도록 설계되있다
    - 네스티드 루프 조인이 사용되기에 적합하지 않은 경우 기존의 Block Nested Loop 대신에 사용한다고 생각하자 (차선책 같은 기능이므로 강제로 쿼리 실행 계획을 해시 조인으로 유도하지 말자)
    - MySQL 8.0.20 버전 부터 네스티드 루프 조인을 사용할 경우 항상 해시 조인이 사용된다

**인덱스 정렬 선호**

- 옵티마이저의 실수가 자주 발생하면 특정 인덱스를 사용하지 못하도록 `IGNORE INDEX` 옵션을 사용했다
- MySQL 8.0.21 버전부터 ORDER BY를 위한 인덱스에 너무 가중치를 부여하지 않도록 `prefer_ordering_index` 옵티마이저 옵션이 추가 되었다

### 조인 최적화 알고리즘

- MySQL에는 조인 쿼리의 실행 계획 최적화를 위한 알고리즘이 2개 있다
- 조인 최적화는 많이 개선되었지만 테이블의 개수가 많아지면 최적화된 실행 계획을 찾는것이 어려워져 실행 계획을 수립하는데 많은 시간이 걸릴 수 있다.
1. Exhaustive 검색 알고리즘
    - MySQL 5.0과 그 이전 버전에서 사용됨
    - FROM 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해 최적의 조합을 1개 찾는 방법
    - 테이블이 20개면 20! Factorial 수행시간이 걸리므로 굉장히 비효율적
2. Greedy 검색 알고리즘
    - Exhaustive 검색 알고리즘의 시간 소모적 문제점을 해결하기 위해 MySQL 5.0 부터 도입된 조인 최적화 기법
    - `optimizer_search_depth` 시스템 변수에 설정된 값에 따라 조인 최적화 비용이 줄어들 수 있음.  시스템 변수의 기본값은 62
    - 조인에 사용된 테이블의 개수가 `optimizer_search_depth` 설정 값 보다 크다면 `optimizer_search_depth` 만큼의 테이블은 Exhaustive 검색, 나머지는 Greedy 검색이 사용됨
    - 조인에 사용된 테이블의 개수가 `optimizer_search_depth` 보다 작다면 Exhaustive 검색만 사용. `optimizer_prune_level` 변수가 0으로 설정된 경우 `optimizer_search_depth`를 4~5로 설정하는것이 좋음
    - `optimizer_prune_level` 시스템 변수는 Heuristic 검색이 작동하는 방식을 제어한다. "1"로 설정되면 Heuristic 알고리즘을 사용하고 0이면 사용하지 않기 때문에 특별한 요건이 아니면 `optimizer_prune_level` 을 0으로 설정하지 말자
    
    과정
    
    1. 전체 N개의 테이블 중에서 `optimizer_search_depth` 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합 생성
    2. 1번에서 생성된 조인 조합중 최소 비용의 실행 계획 하나 설정
    3. 2번에서 선정된 실행 계획의 첫번째 테이블을 부분 실행계획의 첫번째 테이블로 선정
    4. 전체 N-1개의 테이블 중 `optimizer_search_depth` 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 설정
    5. 4번에서 생성된 조인 조합들을 하나씩 3번에서 생성된 부분 실행 계획에 대입해 실행 비용을 계산
    6. 5번의 비용 계산 결과 최적의 실행 계획에서 두 번째 테이블을 3번에서 생성된 부분 실행 계획의 두 번째 테이블로 선정
    7. 남은 테이블이 없어질때까지 4~6번 작업 반복 실행 하며 부분 실행 계획에 테이블의 조인 순서 기록
    8. 최종적으로 부분 실행 계획이 테이블의 조인순서로 결정