
# 9.옵티마이저와 힌트

---

<br>

## 9.2 기본 데이터 처리

---

<br>

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

---

#### 옵티마이저가 풀 테이블 스캔을 선택하는 경우

1. 테이블의 레코드 건수가 너무 작은 경우 (일반적으로 테이블이 페이지 1개로 구성된 경우)
2. WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
3. 인덱스 레인지 스캔을 사용할 수 있는 쿼리더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

<small> (P.232) 인덱스 레인지 스캔 내용 중 인덱스를 통해 읽어야 할 데이터 레코드가 20~25%를 넘으면 인덱스보다 테이블 데이터를 직접 읽는 것이 효율적인 처리 방식이다. </small>

<br>
<br>


#### MySQL 의 풀 테이블 스캔

> NyISAM 은 디스크로부터 페이지를 하나씩 읽어오지만 InnoDB 는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운 스레드에 의해 리드 어헤드 작업이 시작된다. 

1. 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다.
2. 백그라운드 스레드가 읽기를 넘겨받는 시점부터는 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가 시킨다.
3. 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장한다.
4. 포그라운드 스레드는 버퍼 풀에 미리 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 빨리진다.
5. innodb_read_ahead_threshold 시스템 변수를 이용해 리드 어헤드 시작 임계값을 설정할 수 있다.

<br>

<small> 

리드 어헤드 (Read ahead) 란 ?

> 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에 읽어 InnoDB 의 버퍼 풀에 가져다 두는 것을 의미한다. ( 케시 데이터 지역성 중 공간 지역성과 비슷해 보인다. )

버퍼 풀이란 ?

> 테이블(디스크의 데이터 파일) 및 인덱스 데이터를 캐시하는 주 메모리 영역을 버퍼 풀이라 한다. 버퍼 풀은 변경된 데이터를 모아서 처리하기 떄문에 랜덤 I/O 횟수를 줄일 수 있다.

![img.png](img.png)


MySQL 스레딩 구조 P.80

> MySQL 서버는 스레드 기반으로 작동하며 크게 포그라운드, 백그라운드 스레드로 구분된다.

포그라운드 스레드란 (Foreground thread)? P.82

> 포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다.
> 
> 포그라운드 스레드는 데이터를 MySQL 의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.


백그라운드 스레드란 (Background thread)? P.83
+ 인서트 버퍼를 병합하는 스레드
+ <b>로그를 디스크로 기록하는 스레드</b>
+ <b>InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드</b>
+ 데이터를 버퍼로 읽어오는 스레드
+ 잠금이나 데드락을 모니터링하는 스레드

</small>

#### MySQL 의 풀 인덱스 스캔
+ 리드 어헤드는 풀 테이블 스캔과 동일하게 사용된다.

```SQL  
1. 풀 인덱스 스캔을 하는 경우 : MySQL 서버는 단순히 레코드의 건수만 필요로 하는 쿼리라면 용량이 작은 인덱스를 선택하여 I/O 횟수를 줄일 확률이 크다.
SELECT COUNT(*) FROM employees; 


2. 풀 테이블 스캔을 하는 경우 : 레코드에만 있는 칼럼이 필요한 경우에는 풀 테이블 스캔을 한다.
SELECT * FROM employees; 
```

<br>

### 9.2.2 병렬 처리





