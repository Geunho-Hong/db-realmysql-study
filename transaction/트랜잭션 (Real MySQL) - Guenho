# 트랜잭션 (Real MySQL)

### 트랜잭션 (Transaction)

- 더이상 쪼갤 수 없는 작업 단위
- 논리적인 작업셋을 모두 완벽하거나 또는 처리하지 못할 경우 원상태로 복구해서
작업의 일부만 적용되는 현상을 막아 작업의 완전성을 보장한다

### ACID

- 원자성 (Atomicity) : 모두 반영되거나 반영되지 않아야 한다
- 일관성 (Consistency) : 트랜잭션이 성공적으로 완료 되면 일관적인 DB 상태를 유지해야 한다
    
    DataType이나 상태가 변하지 않는 것을 의미한다
    
- 격리성 (Isolation) : 하나의 트랜잭션이 작업을 수행 중 일때 다른 트랜잭션이 끼어들 수 없다
    
    즉, 트랜잭션끼리 독립적으로 수행되어야 한다
    
- 지속성(Durability) : 트랜잭션이 성공적으로 완료되면 수행된 트랜잭션은 영원히 반영된다
즉, 트랜잭션이 성공적으로 완료된 후에는 다른 트랜잭션에 의해 변경되기전까지 영원히 보존되어야 한다

### 잠금(Lock)과 트랜잭션의 차이

- 잠금은 동시성을 제어하기 위한 기능
- 트랜잭션은 데이터의 정합성을 보장하기 위한 기능

하나의 회원 정보를 여러개의 Connection에서 동시에 변경하려고 하는데
Lock 기능이 없다면 하나의 데이터를 여러개의 커넥션에서 동시에 변경할 수 있어
동시성 문제가 발생한다.

> 즉, Lock 기능은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있도록 해준다.
> 

### MySQL에서의 트랜잭션

- 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 한다
- InnoDB 스토리지 엔진은 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다는 트랜
잭션의 원칙을 지킨다

```java
INSERT INTO tbl_professor(professor_no) values(3)
 
INSERT INTO tbl_professor(professor_no) values (1),(2),(3)

result : 3
```

- 위와 같이 InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다는 트랜잭션의
원칙대로 INSERT 문장을 실행 이전으로 돌린다.

MySQL의 기본 Transactaion은 Autocommit 으로 설정되어 있다.
그렇기 때문에 update Query를 날려도 바로 DB에 반영이 되는 것이다.

```java
INSERT INTO tbl_professor(professor_no) values(1)
INSERT INTO tbl_professor(professor_no) values(2)
INSERT INTO tbl_professor(professor_no) values(3)
```

- 위 쿼리문에서 트랜잭션은 몇 번이나 발생했을까?

> 3개를 하나로 묶어서 트랜잭션이 한 번만 발생한 것처럼 보일 수도 있으나, 트랜잭션은 세번 발생했다. 트랜잭션은 더 이상 쪼갤수 없는 작업 단위 이기 때문이며 MySQL은 일반적으로 autocommit 상태이기 때문에 DB에 바로 반영한다.
> 

### 주의사항

- 트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.
- 프로그램 코드에서 트랜잭션의 범위를 최소화 하자.

**아래와 같은 프로세스 절차를 살펴보자.**

---

1. 처리시작
    - DB Connection 생성 및 Transaction 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
9. 알림 메일 발송 이력을 DBMS에 저장
    - 트랜잭션 종료 ( commit )
    - DB Connection 반납
10. 처리 완료

**아래와 같이 변경하자**

---

1.처리 시작

2.사용자의 로그인 여부 확인

3.사용자의 글쓰기 내용의 오류 발생 여부 확인

4.첨부로 업로드된 파일 확인 및 저장

→ DB connection 생성

→ transaction start

5.사용자의 입력 내용을 DBMS 에 저장

6.첨부 파일 정보를 DBMS 에 저장

← transaction commit (종료)

7.저장된 내용 또는 기타 정보를 DBMS 에서 조회

8.게시물 등록에 대한 알림 메일 발송

→ transaction start

9.알림 메일 발송 이력을 DBMS에 저장

← transaction commit

← DB connection

1. 처리 완료

- 이유
    1. DB Connection은 개수가 제한적이다. 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수는 줄어든다 
    2. Network와 통신하는 작업은 반드시 DBMS 트랜잭션 내에서 제거하여야 한다. 프로그램이 실행되는 동안 메일 서버와 통신 할 수 없는 상황이 발생하면 웹 서버 뿐 아니라 DBMS 서버까지 장애가 발생할 수 있다.
    

### MySQL 엔진의 잠금

- MySQL 엔진 : 스토리지 엔진을 제외한 나머지 부분
- 스토리지 엔진 : InnoDB , MyISAM, RocksDB ....
- MySQL의 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다

### 글로벌 락

- `Flush tables with read lock` 명령으로 획득하며 MySQL 잠금 가운데 가장 범위가 크다
- 글로벌 락을 획득하면 SELECT를 제외한 DDL문장이나 DML 문장은 글로벌 락이 해제될 때까지 문장이 대기 상태로 남는다.
- 글로벌 락은 MySQL 서버에 존재하는 모든 테이블에 대해 잠금을 건다. `Flush tables with read lock` 명령은 잠금을 걸기 전 테이블에 먼저 Flush 해야 되기 때문에 테이블에 실행 중인 모든 종류의 쿼리가 완료 되야 한다.
- 글로벌 락은 MySQL 서버의 모든 테이블에 큰 영향을 미치기 때문에 웹 서비스용으로는 지양하자
- InnoDB 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없다. 조금 더 가벼운 글로벌 락의 필요성을 위해 백업 락이 도입되었다.

### 테이블 락

- 테이블 락은 개별 테이블 단위로 설정되는 잠금이다.
- `LOCKS TABLES table_name [READ|WRITE]` 명령으로 사용한다.
- 명시적으로 획득한 잠금은 `UNLOCK TABLES` 명령으로 잠금을 반납 한다.
- 명시적으로 테이블을 잠그는 작업은 글로벌 락과 동일하게 온라인 작업에 큰 영향을 미치기 때문에 특별한 상황이 아니면 사용하지 않는다.
- InnoDB table 은 storage engine 차원에서 record 기반의 잠금을 제공하기 때문에 단순 data 변경 query 로 인해 묵시적인 table lock 이 설정되지 않는다.
    - DML 은 무시되고, DDL 인 경우에 lock 인 경우 영향을 미친다.
    

### 네임드 락

- 테이블이나 레코드가 아니라 `GET LOCK()` 함수를 이용해 임의의 문자열에 대해 잠금을 설정한다
- 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이며 자주 사용되지는 않는다
- 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하다.

### 메타데이터 락

- 데이터 베이스 객체 ( Table, View ) 의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다
- 명시적으로 획득하거나 해제하는 것이 아니라 `RENAME TABLE tab_a to tab_b` 와 같이 테이블의 이름을 변경할 경우 자동으로 획득하는 잠금이다
- 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금을 설정한다
- MySQL 서버의 DDL은 단일 스레드로 작동한다. 그래서 테이블의 구조를 변경할 시 새로운 구조의 테이블을 만들고 범위별로 Insert 하여 여러개의 스레드로 빠르게 복사하는 것이 좋다