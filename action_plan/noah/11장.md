
# 10.실행 계획

---

<br>

## 10.3 실행 계획 분석

---
> 실행 계획에서는 실행 계획이 어떤 접근 방법을 사용해서 어떤 최적화를 수행하는지, 그리고 어떤 인덱슬르 사용하는지 등을 이해하는 것이 중요하다.

+ 실행 계획은 위에서 아래로 순서대로 표시된다.
+ 실행 계획 위쪽에 출력된 결과일수록 쿼리의 바깥 (Outer) 부분이거나 먼저 접근한 테이블이고, 아래쪽일수록 쿼리의 안쪽(Inner) 부분 또는 나중에 접근한 테이블이다.

<br>


### id 컬럼
행이 어떤 SELECT 구문을 나타내는 지를 알려주는 것으로 구문에 서브 쿼리나 UNION이 없다면 SELECT는 하나밖에 없기 때문에 모든 행에 대해 1이란 값이 부여되지만 이외의 경우에는 원 구문에서 순서에 따라 각 SELECT 구문들에 순차적으로 번호가 부여된다.

+ 테이블 접근 순서를 의미하지는 않는다. (접근 순서가 혼란스럽다면 EXPLAIN FORMAT = TREE 명령으로 확인)

### select_type 컬럼

> 각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼

|구분|설명|
|:---:|---|
|SIMPLE | UNION 이나 서브쿼리를 사용하지 않는 단순한 SELECT 
|PRIMARY | UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리
|UNION | UNION(집합을 결합하는) 쿼리에서 PRIMARY 와, DERIVED 제외한 나머지 SELECT
|DEPENDENT_UNION | UNION 과 동일하나, 내부 쿼리가 외부 쿼리의 값을 참조해서 처리할 때 나타나는 키워드 
|UNION_RESULT | UNION 쿼리의 임시 결과물을 담아두는 테이블이며 id 값은 부여되지 않는다.
|SUBQUERY | FROM 절 이외에서 사용되는 그 밖의 모든 서브쿼리
|DEPENDENT SUBQUERY | 서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 커럶을 사용하는 경우
|<u><b>DERIVED</b></u> | (mysql 5.5)FROM 절에 사용되는 서브쿼리, (mysql 5.6) 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 경우
|DEPENDENT DERIVED | 테이블이 래터럴 조인으로 사용된 것을 의미
|UNCACHEABLE SUBQUERY | 서브쿼리와 동일하지만 공급되는 데이이터 값에 대해 서브쿼리를 재처리. 외부 쿼리에서 공급되는 데이터 값이 동일하더라도 캐시된 결과를 사용할 수 없는 경우
|UNCACHEABLE UNION | UNION 과 동일하지만 공급되는 데이이터 값에 대하여 UNION 쿼리를 재처리

#### DERIVED 키워드

> 쿼리를 튜닝하기 위해 실행 계획을 확일할 때 가장 먼저 select_type 이 DERIVED인 것인지 확인하고 join으로 바꿔주는 것이 좋다. 

#### 서브쿼리
+ 중첩된 쿼리(Nested Query) : SELECT 되는 컬럼에 사용된 서브쿼리
+ 서브쿼리(Subquery) : WHERE 절에 사용된 경우
+ 파생 테이블(Derived Table) : FROM 절에 사용된 서브쿼리를 MySQL 에서는 파생테이블이라 하며, 일반적으로 인라인 뷰 또는 서브 셀렉트라 한다.

+ 서브쿼리가 반환하는 값의 특성에 따라 구분되기도 하는데..
    + 스칼라 서브쿼리(Scalar Subquery) : 하나의 값만 반환하는 쿼리
    + 로우 서브쿼리(Row Subquery) : 컬럼의 개수와 관계없이 하나의 레코드만 반환하는 쿼리

### table 컬럼

|구분|설명|
|:---:|---|
| NULL | FROM DUAL 같은 문장을 쓰는 경우
| <derived N>, <union M,N> |  "<>" 둘러싸인 이름은 임시 테이블을 의미

### partitions 컬럼
> 파티션에 대한 실행계획을 표시해준다. 파티션을 지정한 테이블의 경우 type이 ALL로 표시되는데 이는 풀테이블 스캔이 아닌 파티션에 대한 풀스캔을 의미한다. 

### <U><b>type</b></U> 컬럼
> 쿼리의 실행 계획에서 type 이후의 컬럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.
>
> 일반적으로 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 type 컬럼은 반드시 체크해야 할 중요한 정보다.

+ all 키워드를 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이다.
+ 아래는 성능 순서대로 정리한 키워드다.

|구분|설명|
|:---:|---|
|system | 단 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블 참조 (innodb 에서는 나타나지 않는다.) 
|const | 테이블의 레코드 건수와 관계없이 쿼리가 프라이머리 키나 유니크 키 컬럼을 이용하는 WHERE 조건절을 가지며, 반드시 1건을 반환하는 쿼리의 처리 방식
|eq_ref | 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다. 조인에서 처음 읽은 테이블의 컬럼 값을, 그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 컬럼의 검색 조건에 사용할때를 가르킨다.
|ref | eq_ref 와는 달리 조인의 순서와 관계없이 사용되며, 프라이머리 키나 유니크 키 등의 제약 조건도 없다. 인덱스의 종류와 관계 없이 동등(eq) 조건으로 검색할 때는 ref 접근 방법이 사용된다.
|fulltext| 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법
|ref_or_null | ref 와 같지만 null 이 추가되어 검색되는 경우
|unique_subquery | WHERE 조건절에서 사용될 수 있는 IN 형태의 서브쿼리를 위한 접근 방법이며 서브쿼리 결과가 중복이 없는 유니크한 값만 반환하는 경우 ex) select * from where no IN (select..)
|index_subquery | IN 형태의 서브쿼리 결과가 중복된 값을 가진 경우지만 인덱스를 통해 중복된 값을 제거할 수 있다. 
|range | 특정 범위 내(IS NULL, BETWEEN, IN, LIKE)에서 인덱스를 사용하여 원하는 데이터를 추출하는 경우, 레코드 수에 따라 좋고 나쁨이 갈린다.
|index_merge | 2개 이상의 인덱스를 이용해 각각의 검색 결과(OR 조건)를 만든 후, 그 결과를 병합하여 처리하는 방식 
|index | 인덱스를 처음부터 끝까지 찾아서 검색하는 방식이며 인덱스 풀스캔을 뜻한다. (LIMIT 조건과 함께 있다면 성능상 나쁘지 않다.)
|ALL | 테이블 풀스캔

#### <u><b>const, eq_req, ref 비교</b></u>
> const : 조인의 순서와 관계 없이 프라이머리 키나 유니크 키의 모든 컬럼에 대해 동등 조건으로 검색(반드시 1건의 레코드만 반환)
> 
> eq_req : 조인에서 첫 번째 읽은 테이블의 컬럼값을 이용해 두 번째 테이블을 프라이머리 키나 유니크 키로 동등 조건 검색
> 
> ref : 조인의 순서와 인덱스 종류에 관계없이 동등 조건으로 검색(1건의 레코드만 반환한다는 보장이 없어도 됨)

+ 이 세가지 접근 방법 모두 WHERE 절에 사용하는 비교 연산자는 동등 비교 연산자여야 한다는 공통점이 있다. ("=", "<=> : null에 대한 비교 방식만 조금 다르고 = 와 같은 연산")
+  세가지 모두 좋은 접근 방법으로 인덱스 분포다가 나쁘지 않다면 성능상ㅇ 문제를 일으키지 않는 접근 방법이다.

### possible_keys 컬럼
> 말 그대로 옵티마이저가 사용될 법 했던 인덱스 목록을 나타낸다. (후보)

### key 컬럼
> key 컬럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스이며, key 컬럼에 표시되는 값이 원하는 값인지가 중요하다.

### key_len 컬럼
> 쿼리를 처리하기 위해 다중 컬럼으로 구성된 인덱스에서 몇 개의 컬럼까지 사용했는지 나타낸다. 더 정확하게는 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려준다.

### ref 컬럼
> 참조 조건으로 어떤 값이 제공됐는지 보여준다.

+ 참조 조건으로 상숫값을 지정했다면 ref 컬럼의 값은 const 로 표시되고, 다른 테이블의 컬럼값이면 테이블명과 컬럼명이 표시된다.

### rows 컬럼
> 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다. (인덱스를 사용하는 조건에만..)

### filtered 컬럼
> 필터링되고 남은 레코드의 비율을 의미한다.

### extra 컬럼
|구분|설명|
|:---:|:---:|
|using index | 커버링 인덱스라고 하며 인덱스 자료 구조를 이용해서 데이터를 추출
|using where | where 조건으로 데이터를 추출. type이 ALL 혹은 Indx 타입과 함께 표현되면 성능이 좋지 않다는 의미
|using filesort | 데이터 정렬이 필요한 경우로 메모리 혹은 디스크상에서의 정렬을 모두 포함. 결과 데이터가 많은 경우 성능에 직접적인 영향을 줌
|using temporary | 쿼리 처리 시 내부적으로 temporary table이 사용되는 경우를 의미함