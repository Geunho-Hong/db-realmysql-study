## 8.8 클러스터링 인덱스

>  클러스터링 = 여러 개를 하나로 묶는다.

### 8.8.1 클러스터링 인덱스

- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
- 인덱스 알고리즘이라기 보다는 테이블 레코드의 저장 방식, 클러스터링 인덱스 = 클러스터링 테이블, 프라이머리 키 = 클러스터링 키 
- 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안 (공간적 지역성?!)
- 프라이머리 키 값 자체에 대한 의존도가 매우 크다.
    - 프라이머리 키 값에 의해 레코드 저장 위치가 결정
    - 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치도 변경
- InnoDB 스토리지 엔진만 지원
- 클러스터링 테이블은 프라이머리 키 기반 검색 빠름, 레코드 저장이나 프라이머리 키 변경이 상대적으로 느림

#### B-Tree 인덱스와 차이점

클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조

- 테이블 구조 자체는 일반 B-Tree와 유사
- 세컨더리 인덱스를 위한 B-Tree의 리프노드와 달리, 클러스터링 인덱스의 리프 노드에는 모든 칼럼이 같이 저장됨
- B-Tree 인덱스도 인덱스 키 값으로 정렬되어 저장하지만, 오직 테이블 레코드가 프라이머리 키 값으로 정렬되어 저장된 경우만 클러스터링 인덱스라고 함
- ![클러스터링인덱스_B+트리인덱스](https://user-images.githubusercontent.com/33552114/135716408-f8184818-11fe-4964-9749-2e613673af4c.PNG)

#### 클러스터링 테이블에서 프라이머리 키의 변경

레코드가 페이지를 이동

#### InnoDB 스토리지 엔진의 클러스터링 키 후보 선택 우선순위

1. 프라이머리 키가 있으면 클러스터링 키로 기본 선택
2. NOT NULL 옵션의 유니크 인덱스 중 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼 내부적으로 추가한 후, 클러스터링 키로 선택

3번의 내부적으로 생성된 레코드 일련번호 칼럼은 사용자에게 미노출, 쿼리 문장에 명시적 사용도 불가하다. 무의미한 숫자 값으로 클러스터링 되는 것이기에 어떤 혜택도 없음

**InnoDB 테이블에서 클러스터링 인덱스는 테이블당 단 하나만 가질 수 있는 엄청난 혜택이므로 가능하다면 프라이머리 키를 명시적으로 생성하자.**

> MyISAM 테이블이나 기타 InnoDB 제외한 테이블의 데이터 레코드는 프라이머리 키나 인덱스 키 값이 변경된다고 하여 실제 데이터 레코드의 위치가 변경되지 않는다. 인서트 시 데이터 파일의 끝(또는 임의의 빈 공간)에 저장된다. 
>
> 한번 결정된 위치는 절대 바뀌지 않고, 레코드가 저장된 주소(로우 아이디 ROW-ID)는 MySQL 내부적으로 레코드를 식별하는 아이디로 인식된다. 일부 DBMS에서는 이 값을 사용자가 직접 조회하거나 쿼리의 조건으로 사용할 수 있지만, MySQL에서는 사용자에게 노출되지 않는다.

### 8.8.2 세컨더리 인덱스에 미치는 영향

- 클러스터링되지 않은 테이블(MyISAM이나 MEMORY 테이블)의 데이터 레코드는 인서트 시에 저장된 위치가 절대 바뀌지 않는다.
    - 프라이머리 키나 인덱스 키 값이 변경된다고 하더라도..
    - 인서트 시 데이터 파일의 끝(또는 임의의 빈 공간)에 저장됨
- 데이터 레코드가 저장된 주소(로우 아이디 ROW-ID)는 MySQL 내부적으로 레코드를 식별하는 아이디로 인식된다.
- 프라이머리 키나 세컨더리 인덱스의 각 키는 그 주소(ROW-ID)를 이용해 실제 데이터를 찾는다. 
- 즉, 클러스터링되지 않은 테이블에서는 프라이머리 키와 세컨더리 인덱스가 구조적으로 동일한 것
- **클러스터링 테이블의 모든 세컨더리 인덱스는** 해당 레코드가 저장된 주소가 아닌 **프라이머리 키 값을 저장하도록 구현**
    - 클러스터링 키 값이 변경 → 데이터 레코드 주소가 변경 →  해당 테이블의 모든 인덱스에 저장된 주솟값을 변경하는 오버헤드 방지를 위함 

#### 클러스터링/ 넌클러스터링 테이블 검색 예시

```sql
CREATE TABLE employees (
	emp_no INT NOT NULL,
	first_name VARCHAR(20) NOT NULL,
	PRIMARY KEY (emp_no),
	INDEX ix_firstname (first_name)
);

SELECT * FROM employees WHERE first_name='Aamer';
```

employees 테이블에서 first_name 칼럼으로 검색 시,

- MyISAM : ix_firstname 인덱스를 검색해서 레코드 주소를 확인한 후, 레코드 주소를 이용해 최종 레코드를 가져옴
- InnoDB : ix_firstname 인덱스를 검색해 레코드의 프라이머리 키 값을 확인한 후, 프라이머리 키 인덱스를 검색해 최종 레코드 가져옴 (복잡하게 처리되나 더 큰 장점 제공)

### 8.8.3 클러스터링 인덱스의 장점과 단점 (클러스터링 되지 않은 일반 프라이머리 키와 클러스터링 인덱스 비교)

> 빠른 읽기와 느린 쓰기

온라인 트랜잭션 환경(OLTP, On-Line Transaction Processing)에서는 쓰기와 읽기 비율이 2:8, 1:9 이므로 조금 느린 쓰기 감수할 것

#### 장점

- 프라이머리 키(클러스터링 키)로 검색할 때 처리 성능이 매우 빠름, 특히 프라이머리 키를 범위 검색하는 경우 매우 빠름
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(커버링 인덱스)

#### 단점

- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스 크기가 커짐
- 세컨더리 인덱스를 통해 검색할 대 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
- INSERT 할 때 프라이머리 키에 의해 레코드 저장 위치가 결정되므로 처리 성능 느림
- 프라이머리 키 변경 시 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문에 처리 성능 느림

### 8.8.4 클러스터링 테이블 사용 시 주의사항

#### 8.8.4.1 클러스터링 인덱스 키의 크기

- 클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키(클러스터링 키) 값을 포함한다. 

- 프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기 커짐

- InnoDB 테이블의 프라이머리 키는 신중하게 선택할 것 

    - 일반적으로 테이블에 세컨더리 인덱스가 4~5개 정도 생성된다는 것을 고려하면 세컨더리 인덱스 크기는 급격히 증가함, 아래 예시에서 인덱스 크기 190MB 증가

    - | 프라이머리 키 크기 | 레코드당 증가하는 인덱스 크기 | 100만건 레코드 저장 시 증가하는 인덱스 크기 |
        | ------------------ | ----------------------------- | ------------------------------------------- |
        | 10바이트           | 10바이트 * 5 = 50바이트       | 50바이트 * 1,000,000 = 47MB                 |
        | 50바이트           | 50바이트 * 5 = 250바이트      | 250바이트 * 1,000,000 = 238MB               |

    - 인덱스가 커질수록 같은 성능 내기 위해 메모리도 그만큼 더 필요

#### 8.8.4.2 프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 칼럼으로 생성(가능한 경우)

- InnoDB에서는 프라이머리 키로 검색하는 경우(특히 범위 검색 시) 클러스터링되지 않은 테이블에 비해 매우 빠르게 처리될 수 있다.
- 대부분 검색에서도 빈번히 사용된다.
- 따라서, 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 해당 칼럼을 프라이머리 키로 설정할 것

#### 8.8.4.3 프라이머리 키는 반드시 명시할 것

- 가능하면 AUTO-INCREMENT 칼럼을 이용해서라도 프라이머리 키 생성하는 것을 권장한다. 
- 즉, InnoDB 테이블에 프라이머리 키를 정의하지 않는 경우(내부적 일련 번호 칼럼 추가)와 AUTO_INCREMENT 칼럼 생성하고 프라이머리 키 설정하는 것이 결국 동일함
- 사용자가 설정할 수 있는 값(AUTO_INCREMENT값)을 프라이머리로 설정하는 것이 좋음
- +) ROW 기반 복제나 InnoDB Cluster에서는 모든 테이블이 프라이머리 키를 가져야만 정상적인 복제 성능 보장하기도 함

#### 8.8.4.4 AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우

- 인조 식별자(Surrogate key) : 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키
    - 여러 개의 칼럼이 복합으로 프라이머리 키가 만들어지는 경우 프라이머리 키의 크기가 길어질 때가 가끔 있는데, 세컨더리 인덱스가 필요없으면 OK
    - But, 세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO_INCREMENT 칼럼을 추가하고, 이를 프라이머리 키로 설정
- 로그 테이블과 같이 조회보다 INSERT 위주 테이블은 AUTO_INCREMENT를 이용한 인조 식별자를 프라이머리 키로 설정하는 것이 성능 향상에 도움이 된다. 

## 8.9 유니크 인덱스

- 원래 인덱스라기보단 제약 조건 (**테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음**)
- MySQL에서는 인덱스 없이 유니크 제약만 설정할 수 없다.
- 유니크 인덱스에 NULL 저장 가능, 2개 이상 저장될 수 있음
- MySQL에서 프라이머리 키는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동으로 부여됨
- MyISAM이나 MEMORY 테이블의 프라이머리 키 = NULL이 허용되지 않는 유니크 인덱스 / InnoDB 테이블의 프라이머리 키는 클러스터링 키 역할이 추가됨

### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교

유니크 인덱스와 유니크 하지 않은 일반 세컨더리 인덱스 구조 동일

#### 8.9.1.1 인덱스 읽기

> 유니크 인덱스가 더 빠르지 않다 !

- 유니크하지 않은 세컨더리 인덱스에서 한번 더 해야 하는 작업은 디스크 읽기가 아니라 CPU에서 칼럼값을 비교하는 작업이므로 성능상 영향 거의 없음
- 유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야할 레코드가 많아서 느린 것이지, 인덱스 특성 자체 때문에 느린 것이 아님 
- 하나의 값을 검색하는 경우, 유니크 인덱스와 일반 세컨더리 인덱스는 사용되는 실행 계획이 다르다.
- 인덱스 성격 유니크 여부에 따른 차이일 뿐 큰 차이 없음 e.g. 1개의 레코드를 읽냐, 2개 이상의 레코드를 읽냐 차이
- 읽어야할 레코드 건수가 같다면 성능상 차이는 미미하다.

#### 8.9.1.2 인덱스 쓰기

> 유니크 인덱스는 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다 ! 

- 새로운 레코드가 INSERT 되거나 인덱스 칼럼 값이 변경되는 경우 인덱스 쓰기 작업이 필요한데, 유니크 인덱스의 키 값을 쓸 때는 중복된 값의 존재 여부를 체크하는 과정이 추가됨
- MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금 사용, 쓰기 할 때는 쓰기 잠금 사용하는데 이 과정에서 *데드락*이 빈번하게 발생
- InnoDB 스토리지 엔진에는 인덱스 키의 저장을 버퍼링하기 위해 *체인지 버퍼*(Change Buffer)가 사용된다. 인덱스 저장이나 변경 작업이 상당히 빨리 처리되지만, 유니크 인덱스는 반드시 중복 체크 해야하므로 작업 자체를 버퍼링하지 못한다.

> ##### Ref. 129P 체인지 버퍼
>
> 레코드가 INSERT되거나 UPDATE될 때는 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스 업데이트 작업이 필요
>
> 인덱스를 업데이트하는 작업은 랜덤 디스크 읽기이므로 테이블에 인덱스가 많다면 상당한 자원 소모
>
> *InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만, 그렇지 않고 디스크로부터 읽어와 업데이트 해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해두고 사용자에게 결과 반환함으로써 성능 향상, 이때 사용하는 임시 메모리 공간을 체인지 버퍼라고 한다.*
>
> **사용자에게 결과를 전달하기 전 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 사용 불가하다.**
>
> 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이 스레드를 체인지 버퍼 머지 스레드라고 한다. 

### 8.9.2 유니크 인덱스 사용 시 주의사항

> 유일성이 꼭 보장돼야 하는 칼럼에 대해서만 유니크 인덱스 생성하고, 꼭 필요하지 않으면 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 고려할 것

- MySQL의 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로, 하나의 테이블에서 같은 컬럼에 중복해서 생성할 필요가 없다.
- 똑같은 칼럼에 프라이머리 키와 유니크 인덱스 중복 생성도 불필요한 중복이다.
- 유니크 인덱스는 쿼리 실행 계획이나 테이블 파티션에 미치는 영향도 있음 

## 8.10 외래키

- MySQL에서는 InnoDB 스토리지 엔진만 가능
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.
- 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.

#### InnoDB의 외래키 관리의 중요 특징

- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.

### 8.10.1 자식 테이블의 변경이 대기하는 경우

![외래키1](https://user-images.githubusercontent.com/33552114/135716411-792f18b3-a0d7-4a4f-be4c-7ef73202c57a.PNG)

자식 테이블의 외래키 칼럼의 변경(INSERT, UPDATE)은 부모 테이블의 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려있으면 해제될 때까지 기다리게 된다.

자식 테이블의 외래키가 아닌 칼럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않는다. 

### 8.10.1 부모 테이블의 변경 작업이 대기하는 경우

![외래키2](https://user-images.githubusercontent.com/33552114/135716413-4110bb60-d5fc-4e0c-a560-79bfad198f90.PNG)

자식 테이블의 레코드에 대한 쓰기 잠금이 해제될 때까지 기다려야 한다. 자식 테이블이 생성될 때 정의된 오래키의 특성(ON ELETE CASCADE) 때문에 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제되는 식으로 작동하기 때문이다.

> 물리적으로 외래키를 생성하면 자식 테이블에 레코드가 추가되는 경우 해당 참조키가 부모 테이블에 있는지 체크한다.
>
> 체크 작업을 위해 연관 테이블에 읽기 잠금을 걸게 되는 것, 잠금이 다른 테이블로 확장되면 전체 쿼리 동시 처리에 영향을 미친다. 
>
> 잠금 경합까지 고려해서 모델링 할 것 ! 