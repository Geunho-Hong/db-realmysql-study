
## InnoDB vs MyISAM

---

InnoDB 엔진은 트랜잭션 처리가 필요하고 대용량의 데이터를 다루는 부분에서 효율적이고, MyISAM 엔진은 트랜잭션 처리가 필요 없고, Read only 기능이 많은 서비스일수록 효율적이다.

### InnoDB 

+ MyISAM 의 단점인 Row-Level Locking 을 지원한다.
+ CPU 효율이 좋고, 자체적으로 메인 메모리 안에 데이터 캐싱과 인덱싱을 위한 버퍼 풀(pool)을 관리한다.
+ 대용량 데이터를 처리에 좋다.
+ 많은 기능을 제공한다
  + ex) commit, rollback, 장애복구, row-level locking, 외래키 ...
+ 전문검색시 n-gram에 한정된다.

### MyISAM

+ 전문 검색이 가능하다.
+ 읽기에 최적의 성능을 발휘한다.
+ 테이블과 인덱스를 각각 분리된 파일로 관리한다.

<br>

## 8.5 전문 검색 인덱스

---

> 전문 검색이란? 게시물의 내용이나 제목 등과 같이 문장이나 문서의 내용에서 키워드를 검색을 뜻한다.
> 전문 검색 인덱스란 ? 문서 내용 전체에 대한 분석과 검색을 위한 인덱싱 알고리즘을 전문 검색 인덱스라 한다.

+ 전문(Full Text) 검색에는 InnoDB 나 MyISAM 스토리지 엔진에서 제공하는 기본적으로 제공하는 B-Tree 인덱스는 사용할 수 없다. 
+ 전문검색은 이름이나 별명(닉네임) 과 같은 단어에서 일부만 일치하는 사용자를 검색하는 기능으로도 사용 할 수 있다.
  + 전문 검색은 LIKE 기능과 같이 패턴 일치 검색 기능(LIKE = (%%)을 사용한)  일부만 검색하는 경우에도 인덱스를 탄다.

### 8.5.1 인덱스 알고리즘

---

#### 8.5.1.1 어근 분석

---

> MySQL 서버의 전문 검색 인덱스는 두 가지 중요한 과정을 거쳐 색인 작업이 수행된다. 

- [ ] 불용어(stop word) 처리
  + 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업을 의미한다.
  + 불용어의 개수는 보통 상수로 정의해서 사용한다.
  + 유연성을 위해서 불용어 자체를 데이터베이스화해서 사용자가 CRUD 를 구현하는 경우도 있다.
  + MySQL 서버는 불용어가 소스코드에 정의돼 있지만, 이를 무시하고 사용자가 별도로 불용어를 정의할 수 있다.
  

- [ ] 어근 분석(stemming)
  + 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업이다.
  + 오픈소스 형태소 분석 라이브러리인 MeCab 을 프로그인 형태로 사용할 수 있게 지원한다.
  + 한글이나 일본어의 경우 영어와 같이 단어의 변형 자체는 거의 없기 때문에 어근 분석보단 문장의 형태소를 분석해서 명사와 조사를 구분하는 기능이 더 중요하다.
  + 서구권 언어를 위한 형태소 분석기는 MongoDB 에서 사용되는 Snowball 이라는 오픈 소스가 존재한다.

<br>

#### 8.5.1.2 n-gram 알고리즘

--- 

<br> 

## 8.6 함수 기반 인덱스

> 컬럼의 값을 변형해서 만들어진 값에 대한 인덱스를 구축해야 할 때 함수 기반 인덱스를 활용한다.
> MySQL 8. 버전부터 지원하며 가상 컬럼을 이용한 인덱스와 함수를 이용한 인덱스가 있다.

+ 함수 기반 인덱스는 인덱싱할 값을 계산하는 과정의 차이만 있을 뿐, 실제 인덱스의 내부적인 구조는 B-Tree 인덱스와 동일하다.

### 8.6.1 가상 컬럼을 이용한 인덱스

```SQL
CREATE TABLE 유저 (
  이름 VARCHAR(10)
  성 VARCHAR(10)
)

ALTER TABLE 유저 
    ADD full_name VARCHAR(30) AS (CONCAT(이름,'',성)) VIRTUAL,
    ADD INDEX ix_full_name (full_name)
```

+ WHERE full_name = '문승찬'
+ 가상 컬럼은 테이블에 새로운 컬럼을 추가하는 것과 같은 효과를 내기 떄문에 실제 테이블의 구조가 변경된다는 단점이 있다.

### 8.6.2 함수를 이용한 인덱스

+ 테이블 구조를 변경하지 않고, 계산된 결과값의 검색을 빠르게 만들어준다.
+ 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 한다.
  + WHERE CONCAT(이름, '', 성) = '문승찬'
  

## 8.7 멀티 밸류 인덱스

> MySQL 5. 버전부터 json 타입 컬럼을 지원하였지만 이에 대한 인덱스를 지원하지 않았다. 8. 버전부턴 이런 컬럼들에 대한 멀티 밸류 인덱스를 지원한다.

+ 멀티 밸뷰 인데스를 활용하기 위해서는 일반적인 조건 방식을 사용하면 안되고, 반드시 다음 함수들을 이용해야 한다.
  + MEMBER OF()
  + JSON_CONTAINS()
  + JSON_OVERLAPS()
  

